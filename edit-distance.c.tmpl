#linein
#include <stdio.h>
/* For INT_MAX/INT_MIN */
#include <limits.h>
/* For malloc. */
#include <stdlib.h>

#include "config.h"
#include "text-fuzzy.h"
#include "edit-distance-[% stem %].h"
[%- IF ed_type == 'int' %]
[%- format = '%d' %]
[%- ELSIF ed_type == 'char' %]
[%- format = '%c' %]
[% ELSE %]
[% format = 'format' _ ed_type # Cause an error %]
[%- END %]
[%- IF trans %]
#linein

/* A linked list of key and position. */

struct dictionary
{
    /* The character. */
    [% type %] key; 
    /* The occurrence of the character. */
    unsigned int value;
    struct dictionary * next;
};

typedef struct dictionary item;

static int
minimum (int a, int b)
{
    if (a > b) {
	return b;
    }
    return a;
}

typedef struct
{
    item * items;
    /* Top of the stack. */
    int top;
    /* Largest value. */
    int max;
}
stack_t;

static int
push (stack_t * stack, [% type %] key)
{
    stack->items[stack->top].key = key;
    stack->items[stack->top].value = 0;
    stack->top++;
    if (stack->top >= stack->max) {
	fprintf (stderr, "%s:%d: stack overflow",
		 __FILE__, __LINE__);
	return -1;
    }
    return 0;
}

static int
unique_push (stack_t * stack, [% type %] key)
{
    int i;
    for (i = stack->top - 1; i >= 0; i--) {
	if (stack->items[i].key == key) {
	    return 0;
	}
    }
    return push (stack, key);
}

/* Find key in stack. */

static int
find (stack_t * stack, [% type %] key)
{
    int i;
    for (i = stack->top - 1; i >= 0; i--) {
	if (stack->items[i].key == key) {
	    return stack->items[i].value;
	}
    }
    fprintf (stderr, "%s:%d: [% format %] not found\n",
	     __FILE__, __LINE__, key);
    return 0;
}

/* Set the value of stack[key] to value. */

static int
set (stack_t * stack, [% type %] key, int value)
{
    int i;
    for (i = stack->top - 1; i >= 0; i--) {
	if (stack->items[i].key == key) {
	    stack->items[i].value = value;
	    return 0;
	}
    }
    fprintf (stderr, "%s:%d: could not set element [% format %]: not found.\n",
	     __FILE__, __LINE__, key);
    return -1;
}

[%- END %]
#lineout
[% INCLUDE declaration %]
{
[% IF ed_type == 'int' %]
[% length = 'ulength' %]
[% value = 'unicode' %]
[% ELSIF ed_type == 'char' %]
[% length = 'length' %]
[% value = 'text' %]
[% ELSE %]
    fprintf (stderr, "Unhandled type [% type %].\n");
    exit (1);
[% END # ed_type %]
#linein
[%- IF use_text_fuzzy %]
#linein

    const [% type %] * word1 = (const [% type %] *) tf->b.[% value %];
    int len1 = tf->b.[% length %];
    const [% type %] * word2 = (const [% type %] *) tf->text.[% value %];
    int len2 = tf->text.[% length %];
[%- END # use_text_fuzzy %]
    /* Return value. */
    int d;
    /* X and Y coordinates in the matrix of strings. */
    int i;
    int j;
[%- IF use_text_fuzzy %]
#linein
    int max;
[%- END # use_text_fuzzy %]
#linein
[%- IF trans %]
#linein
    unsigned int swap_score;
    unsigned int char_count;
    unsigned int score_ceil;
    int size1 = len1 + 2;
    int size2 = len2 + 2;
    stack_t stack = {0};
#ifdef __GNUC__
    unsigned int matrix[size1][size2];
    item items[size1 + size2];
#else
    unsigned int ** matrix;
    item * items;
#endif
[%- IF use_text_fuzzy %]
    max = tf->max_distance;
[%- END # use_text_fuzzy %]
    stack.max = size1 + size2;

    score_ceil = len1 + len2;

    /* First handle the two extreme cases of one or the other strings
       being empty. */

    if (len1 == 0) {
	return len2;
    }
    if (len2 == 0) {
	return len1;
    }
 
#ifndef __GNUC__

    /* User's compiler cannot allocate on the stack. */

    matrix = calloc (size1, sizeof (unsigned int *));
    if (! matrix) {
	fprintf (stderr, "%s:%d: malloc failed.\n",
		 __FILE__, __LINE__);
	return -1;
    }
    for (i = 0; i < size1; i++) {
	matrix[i] = calloc (size2, sizeof (unsigned int));
	if (! matrix[i]) {
	    fprintf (stderr, "%s:%d: calloc failed.\n",
		     __FILE__, __LINE__);
	    return -1;
	}
    }

    items = calloc (len1 + len2, sizeof (item));
    if (! items) {
	fprintf (stderr, "%s:%d: calloc failed for %d x %d\n",
		 __FILE__, __LINE__, len1 + len2, sizeof (item));
	return -1;
    }

#endif /* __GNUC__ */

    /* Has to go after the above. */

    stack.items = items;

    /* Initialize the dynamic programming matrix's values. */

    matrix[0][0] = score_ceil;  
    matrix[1][0] = score_ceil;
    matrix[0][1] = score_ceil;
    matrix[1][1] = 0;

    /* This stack tracks the characters we have seen for the sake of
       transpositions. */

    unique_push (& stack, word1[0]);
    unique_push (& stack, word2[0]);

    for (i = 1; i <= len1; i++) { 
	int swap_count;

	unique_push (& stack, word1[i]);

	matrix[i+1][1] = i;
	matrix[i+1][0] = score_ceil;
	
	swap_count = 0;

	for (j = 1; j <= len2; j++) {
	    if (i == 1) {
		/* Only initialize on the first pass.     */
		/* Optimized over two additional "for" loops. */
		unique_push (& stack, word2[j]);
		matrix[1][j + 1] = j;
		matrix[0][j + 1] = score_ceil;
	    }
	    char_count = find (& stack, word2[j - 1]);
	    swap_score = matrix[char_count][swap_count] + i
		- char_count - 1 + j - swap_count;
	    
	    if (word1[i - 1] != word2[j - 1]) {      
		int x;
		int y;
		x = minimum (matrix[i+1][j], matrix[i][j + 1]);
		y = minimum (matrix[i][j], x);
		matrix[i + 1][j + 1] = minimum (swap_score, (y + 1));
	    }
	    else { 
		swap_count = j;
		matrix[i + 1][j + 1] = minimum (matrix[i][j], swap_score);
	    } 
	}
	/* This is the only time we set the values in the stack. */
	set (& stack, word1[i - 1], i);
    }

    d = matrix[len1 + 1][len2 + 1];

#ifndef __GNUC__
    free (stack);
    for (i = 0; i < len1 + 2; i++) {
	free (matrix[i]);
    }
    free (matrix);
#endif /* __GNUC__ */
[%- ELSE # not trans %]
#linein

    /* Matrix is the dynamic programming matrix. We economize on space
       by having only two columns. */

#ifdef __GNUC__
    int matrix[2][len2 + 1];
#else
    int * matrix[2];
#endif
    int large_value;

[%- IF use_text_fuzzy %]
    max = tf->max_distance;
[%- END # use_text_fuzzy %]

#ifndef __GNUC__
    for (i = 0; i < 2; i++) {
	matrix[i] = calloc (len2 + 1, sizeof (int));
	if (! matrix[i]) {
	    fprintf (stderr, "%s:%d: calloc failed.\n",
		     __FILE__, __LINE__);
	    return -1;
	}
    }
#endif

    /*
      Initialize the 0 row of "matrix".

        0  
        1  
        2  
        3  

     */

    if (max != NO_MAX_DISTANCE) {
        large_value = max + 1;
    }
    else {
        if (len2 > len1) {
            large_value = len2;
        }
        else {
            large_value = len1;
        }
    }

    for (j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }

    /* Loop over column. */
    for (i = 1; i <= len1; i++) {
        [% type %] c1;
        /* The first value to consider of the ith column. */
        int min_j;
        /* The last value to consider of the ith column. */
        int max_j;
        /* The smallest value of the matrix in the ith column. */
        int col_min;
        /* The next column of the matrix to fill in. */
        int next;
        /* The previously-filled-in column of the matrix. */
        int prev;

        c1 = word1[i-1];
        min_j = 1;
        max_j = len2;
        if (max != NO_MAX_DISTANCE) {
            if (i > max) {
                min_j = i - max;
            }
            if (len2 > max + i) {
                max_j = max + i;
            }
        }
        col_min = INT_MAX;
        next = i % 2;
        if (next == 1) {
            prev = 0;
        }
        else {
            prev = 1;
        }
        matrix[next][0] = i;
        /* Loop over rows. */
        for (j = 1; j <= len2; j++) {
            if (j < min_j || j > max_j) {
                /* Put a large value in there. */
                matrix[next][j] = large_value;
            }
            else {
                [% type %] c2;

                c2 = word2[j-1];
                if ([% compare_c1_c2 %]) {
                    /* The character at position i in word1 is the same as
                       the character at position j in word2. */
                    matrix[next][j] = matrix[prev][j-1];

                }
                else {
                    /* The character at position i in word1 is not the
                       same as the character at position j in word2, so
                       work out what the minimum cost for getting to cell
                       i, j is. */
                    int delete;
                    int insert;
                    int substitute;
                    int minimum;

                    delete = matrix[prev][j] + [% delete_cost %];
                    insert = matrix[next][j-1] + [% insert_cost %];
                    substitute = matrix[prev][j-1] + [% substitute_cost %];
                    minimum = delete;
                    if (insert < minimum) {
                        minimum = insert;
                    }
                    if (substitute < minimum) {
                        minimum = substitute;
                    }
                    matrix[next][j] = minimum;
                }
            }
            /* Find the minimum value in the ith column. */
            if (matrix[next][j] < col_min) {
                col_min = matrix[next][j];
            }
        }
        if (max != NO_MAX_DISTANCE) {
            if (col_min > max) {
                /* All the elements of the ith column are greater than the
                   maximum, so no match less than or equal to max can be
                   found by looking at succeeding columns. */

#ifndef __GNUC__
		for (i = 0; i < 2; i++) {
		    free (matrix[i]);
		}
#endif
                return large_value;
            }
        }
    }
    d = matrix[len1 % 2][len2];

#ifndef __GNUC__
    for (i = 0; i < 2; i++) {
	free (matrix[i]);
    }
#endif
[%- END # trans %]
#linein
    return d;
}

/* Some people are not using GCC-compatible compilers. See, for
   example, this test failure.
   http://ppm4.activestate.com/sun4-solaris-64/5.12/1200/B/BK/BKB/Text-Fuzzy-0.11.d/log-20130328T025706.txt */

